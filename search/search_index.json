{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FunChill documentation Welcome to the FunChill programming language documentation! If this is your first time here, you should certainly have a look to the introduction to FunChill . You can then explore more in depth features by navigating from the introduction page, or go to straight to the language reference for an index of the reference pages. Have fun, and stay chill!","title":"Home"},{"location":"#welcome-to-funchill-documentation","text":"Welcome to the FunChill programming language documentation! If this is your first time here, you should certainly have a look to the introduction to FunChill . You can then explore more in depth features by navigating from the introduction page, or go to straight to the language reference for an index of the reference pages. Have fun, and stay chill!","title":"Welcome to FunChill documentation"},{"location":"about/","text":"About FunChill FunChill has been created as a school project by 5 Epitech students. It is designed to be easy to use, and also decently easy to implement, since we obviously have to respect a due date. The main idea throughout the FunChill design is that everything should be chill : nothing should be horrendously long to write, nor unreadable for no reason. It's an accumulation of simple decisions that keep the language simple to use. A good example of that is that semicolons at end of statement are optional, a simple linebreak works too. The fun keyword aims at being a nice little reminder that you should always try to have fun and enjoy the time you spend programming. Team Florent Charpentier Thibaut Hebert-Henriette Landry Gigant Florian Gaudin Hugues Lejeune","title":"About"},{"location":"about/#about-funchill","text":"FunChill has been created as a school project by 5 Epitech students. It is designed to be easy to use, and also decently easy to implement, since we obviously have to respect a due date. The main idea throughout the FunChill design is that everything should be chill : nothing should be horrendously long to write, nor unreadable for no reason. It's an accumulation of simple decisions that keep the language simple to use. A good example of that is that semicolons at end of statement are optional, a simple linebreak works too. The fun keyword aims at being a nice little reminder that you should always try to have fun and enjoy the time you spend programming.","title":"About FunChill"},{"location":"about/#team","text":"Florent Charpentier Thibaut Hebert-Henriette Landry Gigant Florian Gaudin Hugues Lejeune","title":"Team"},{"location":"introduction/","text":"Introduction to FunChill The FunChill programming language is a C-like language which aims at being simple to read and write while providing sensible features. Quick example Here is a simple factorial function written in FunChill. fun my_factorial(i32 n): i32 { if (n < 0) { return -1 // -1 is returned as an error } if (n <= 1) { return 1 } return n * my_factorial(n - 1) } As you can see from this example, FunChill is very similar to modern C-like programming languages so it should be simple to learn both for beginners or experienced developers. Some key features in this code snippet are: fun is used to introduce a function declaration : declares the function return type Semicolons at line endings are optional Overview of features This overview aims at giving you an idea of what's available in the language and how to do basic things. For more detail about a specific topic, follow the links from the overview; or for a complete overview of what's available, have a look at the language reference pages . Built-in types Here is a table of the basic types: Type identifier Description i8 8 bits signed integer i16 16 bits signed integer i32 32 bits signed integer i64 64 bits signed integer u8 8 bits unsigned integer u16 16 bits unsigned integer u32 32 bits unsigned integer u64 64 bits unsigned integer bool Boolean value ( true / false ) () Unit type (empty tuple) See more information about types, and the full type table in the type reference . Operators FunChill features all basic arithmetic and logical operators you would expect from any programming language. Here is a short list of all operators: Prefix + / - : Sign prefixes, so that you can write signed number literals ( -75 , +3 ) Prefix ! : Logical not operator All arithmetic + - * / % : For addition, subtraction, multiplication, division and modulus. Comparison operators: > >= < <= Equality operators: == and != Boolean logical operators: && and || Addition and subtraction have lower precedence than the others, so 1 + 2 * 3 is indeed parsed as 1 + (2 * 3) . For a complete reference of operators associativity and precedence, see the full operator table . Functions Functions can only be declared in the global scope. A function declaration is introduced by the fun keyword, followed by the function identifier, the parameter list, the return type and the function body. Here is a simple example: fun my_add(i32 a, i32 b): i32 { return a + b } A function body consists of zero or more statements wrapped in curly braces. In general, a statement can be a variable declaration, a function call or a return statement for example. See the complete list of statements here . If you have a function which returns () , you can omit the return type: // Explicit return type of `()` fun my_function(i32 i): () {} // Implicit return type of `()` fun my_function(i32 i) {} If your function takes no parameters, you can omit the parameter list: // Explicit empty parameter list fun my_get_int(): i32 { return 42 } // Omitted parameter list fun my_get_int: i32 { return 42 } It is also possible to omit both the parameter list and the return type: fun f {} Main function To declare the main function to your program, use the main keyword, followed by a parameter list, a return type, and a function body. Everything that can be omitted in a function declaration can also be omitted in a main declaration. main(): i32 { return 42 } Comments Comments are just what you expect them to be. Use // to introduce a line comment: all characters until the end of line will be ignored. // I am a comment fun f { // Comment after opening brace // Comment inside a function i32 a = 0 // Comment after a variable // Weirdly indented comment } // Comment after closing brace You can also use /* and */ to introduce a block comment \u2212 that is \u2212 to ignore all characters between the opening /* and the closing */ . As of 2.0, nested block comments are not supported, such that /* /* /* */ represents a single, syntactically valid block comment, while /* /* */ */ represents a block comment followed by a trailing */ which will certainly cause a parsing error. /* This is a block comment */ fun /*inline block comment*/ myfunc/* abc */(i32 a /*, i32 b*/)/*: ()*/ /* { return } */ { some_other_func(a) }","title":"Intro"},{"location":"introduction/#introduction-to-funchill","text":"The FunChill programming language is a C-like language which aims at being simple to read and write while providing sensible features.","title":"Introduction to FunChill"},{"location":"introduction/#quick-example","text":"Here is a simple factorial function written in FunChill. fun my_factorial(i32 n): i32 { if (n < 0) { return -1 // -1 is returned as an error } if (n <= 1) { return 1 } return n * my_factorial(n - 1) } As you can see from this example, FunChill is very similar to modern C-like programming languages so it should be simple to learn both for beginners or experienced developers. Some key features in this code snippet are: fun is used to introduce a function declaration : declares the function return type Semicolons at line endings are optional","title":"Quick example"},{"location":"introduction/#overview-of-features","text":"This overview aims at giving you an idea of what's available in the language and how to do basic things. For more detail about a specific topic, follow the links from the overview; or for a complete overview of what's available, have a look at the language reference pages .","title":"Overview of features"},{"location":"introduction/#built-in-types","text":"Here is a table of the basic types: Type identifier Description i8 8 bits signed integer i16 16 bits signed integer i32 32 bits signed integer i64 64 bits signed integer u8 8 bits unsigned integer u16 16 bits unsigned integer u32 32 bits unsigned integer u64 64 bits unsigned integer bool Boolean value ( true / false ) () Unit type (empty tuple) See more information about types, and the full type table in the type reference .","title":"Built-in types"},{"location":"introduction/#operators","text":"FunChill features all basic arithmetic and logical operators you would expect from any programming language. Here is a short list of all operators: Prefix + / - : Sign prefixes, so that you can write signed number literals ( -75 , +3 ) Prefix ! : Logical not operator All arithmetic + - * / % : For addition, subtraction, multiplication, division and modulus. Comparison operators: > >= < <= Equality operators: == and != Boolean logical operators: && and || Addition and subtraction have lower precedence than the others, so 1 + 2 * 3 is indeed parsed as 1 + (2 * 3) . For a complete reference of operators associativity and precedence, see the full operator table .","title":"Operators"},{"location":"introduction/#functions","text":"Functions can only be declared in the global scope. A function declaration is introduced by the fun keyword, followed by the function identifier, the parameter list, the return type and the function body. Here is a simple example: fun my_add(i32 a, i32 b): i32 { return a + b } A function body consists of zero or more statements wrapped in curly braces. In general, a statement can be a variable declaration, a function call or a return statement for example. See the complete list of statements here . If you have a function which returns () , you can omit the return type: // Explicit return type of `()` fun my_function(i32 i): () {} // Implicit return type of `()` fun my_function(i32 i) {} If your function takes no parameters, you can omit the parameter list: // Explicit empty parameter list fun my_get_int(): i32 { return 42 } // Omitted parameter list fun my_get_int: i32 { return 42 } It is also possible to omit both the parameter list and the return type: fun f {}","title":"Functions"},{"location":"introduction/#main-function","text":"To declare the main function to your program, use the main keyword, followed by a parameter list, a return type, and a function body. Everything that can be omitted in a function declaration can also be omitted in a main declaration. main(): i32 { return 42 }","title":"Main function"},{"location":"introduction/#comments","text":"Comments are just what you expect them to be. Use // to introduce a line comment: all characters until the end of line will be ignored. // I am a comment fun f { // Comment after opening brace // Comment inside a function i32 a = 0 // Comment after a variable // Weirdly indented comment } // Comment after closing brace You can also use /* and */ to introduce a block comment \u2212 that is \u2212 to ignore all characters between the opening /* and the closing */ . As of 2.0, nested block comments are not supported, such that /* /* /* */ represents a single, syntactically valid block comment, while /* /* */ */ represents a block comment followed by a trailing */ which will certainly cause a parsing error. /* This is a block comment */ fun /*inline block comment*/ myfunc/* abc */(i32 a /*, i32 b*/)/*: ()*/ /* { return } */ { some_other_func(a) }","title":"Comments"},{"location":"reference/","text":"FunChill language reference The FunChill reference contains in-depth documentation pages about specific features of the language. If you just want to have an idea of what FunChill code looks like without too much detail, you should rather go to the FunChill overview . If you want to see a formal definition of the language, you can have a look at the FunChill formal grammar . Here is the list of reference pages: Operator table List of keywords Types Expressions Statements Whitespace in FunChill","title":"Index"},{"location":"reference/#funchill-language-reference","text":"The FunChill reference contains in-depth documentation pages about specific features of the language. If you just want to have an idea of what FunChill code looks like without too much detail, you should rather go to the FunChill overview . If you want to see a formal definition of the language, you can have a look at the FunChill formal grammar . Here is the list of reference pages: Operator table List of keywords Types Expressions Statements Whitespace in FunChill","title":"FunChill language reference"},{"location":"reference/expressions/","text":"FunChill expressions In FunChill, the concept of an expression is rather simple: it refers to anything that has a value, such as numbers or variables. An important thing about expression is that they can always be assigned a type. Expressions are a recursive data structure: many language constructs allow creating expressions from one or many other expressions. For example, when you write 1 + 2 , 1 is an atomic expression , same goes for 2 , and 1 + 2 as a whole is also an expression: an operation expression Different levels of expressions In order to express things such as operator precedence or simply the way expressions are delimited, they are defined in different levels, and eventually recursing to the lowest level with parentheses wrapping expressions. Atomic expressions Atomic expressions are the most basic building block for expressions. There are only three kinds of atomic expressions: Numeric literals (i.e. 123 ) Boolean literals ( true / false ) Identifiers (names of variables or functions) Numeric literals default to the i32 type. Boolean literals of course have the bool type. Identifiers' type are known where the identifier has been declared. Primary expressions Primary expressions are the basic structure from which expressions can be constructed recursively. There are three kinds of primary expressions: Atomic expressions (of course atomic expressions can be used to construct higher order expressions) \"Grouped\" expressions: parenthesised expressions . This allows breaking operator precedence Block expressions: a language construct which wraps zero or more statements in an expression, which allows writing imperative code in conditional expressions for example Grouped expressions have the type of the wrapped expressions. As of 2.0, block expressions have the unit type () . Operation expressions Operation expressions are the result of applying operators on primary expressions . An application of zero operators on a primary expression also counts as a valid operation expression. For a full list of operators, see the operator table . Conditional expressions Conditional expressions are the most basic control flow structure in FunChill. In total, 4 conditional expressions exist: if if ... else unless unless ... else The expressions if and unless with no else are formed of 2 sub-expressions. if ... else and unless ... else are formed of 3 sub-expressions. All sub-expressions part of conditional expressions can be any type of expression . The expression unless (A) ... is just syntactic sugar for if (!A) ... . The condition is considered satisfied when it evaluates to true in the case of if , and when it evaluates to false in the case of unless . All four conditional expressions expect their condition as a parenthesised expression of type bool . In the case of if / unless without an else arm, an expression of type () is expected after the condition. If and only if the condition is satisfied, then the expression will be evaluated (and may produce side effects), then the control flow will continue right after, no matter whether the condition has been satisfied. These conditionals will always evaluate to () . In the case of if ... else and unless ... else , a second expression is expected after the else block. Both expressions before and after the else must be of the same type. If the condition is satisfied, the first expression will be evaluated and the whole conditional will evaluate to its first arm. Otherwise, the second expression will be evaluted and the whole conditional will evaluate to its second arm. Conditional loops Conditional loops are a simple control flow structure in FunChill, some of them are someway similar to conditional expressions. In total, 4 conditional loops exist: while until do ... while do ... until The expressions while and until with no do are formed of 2 sub-expressions. do ... while and do ... until are also formed of 2 sub-expressions but they evaluate them in the reverse order. All sub-expressions part of conditional loops can be any type of expression . The expression until (A) ... is just syntactic sugar for while (!A) ... . The condition is considered satisfied when it evaluates to true in the case of while , and when it evaluates to false in the case of until . All four conditional loops expect their condition as a parenthesised expression of type bool . In the case of while / until , an expression of type () is expected after the condition. If and only if the condition is satisfied, then the expression will be evaluated (and may produce side effects), then the control flow will re-evaluate the whole loop until the condition is no longer satisfied. In the case of do ... while and do ... until , a do keyword followed by an expression of type () is expected before the condition. The expression is evaluated before the control flow evaluates the condition. As for while / until loops, if the condition is evaluated to true / false , the whole loop is re-evaluated. After a conditional loop ends, the control flow continue to evaluate the next instructions. Iterative loops Iterative loops are a complex control flow structure in FunChill with a behavior similar to conditional loops. Only one iterative loops exists: for ... in The expression for ... in is formed of 2 statements and 1 sub-expression: a variable declaration, a range definition (defined as (a,b) ), an expression of any type . The for ... in loop first declares a locally scoped integer variable and assigns it to the first value of the range. The control flow then evaluates the sub-expression and increment the local variable of 1 . The control flow re-evaluate the loop (except the variable declaration) until the variable becomes equal to or greater than the last value of the range. After an iterative loop ends, the control flow continue as for conditional loops. General expressions \"General\" expressions are what is commonly referred to as \"expressions\" in the rest of this documentation. They can be either operation expressions or conditional expressions . Note that since operations expressions are made of zero or more operations, an atomic expression such as 3 will indeed qualify as a \"general\" expression. Back to reference index","title":"Expressions"},{"location":"reference/expressions/#funchill-expressions","text":"In FunChill, the concept of an expression is rather simple: it refers to anything that has a value, such as numbers or variables. An important thing about expression is that they can always be assigned a type. Expressions are a recursive data structure: many language constructs allow creating expressions from one or many other expressions. For example, when you write 1 + 2 , 1 is an atomic expression , same goes for 2 , and 1 + 2 as a whole is also an expression: an operation expression","title":"FunChill expressions"},{"location":"reference/expressions/#different-levels-of-expressions","text":"In order to express things such as operator precedence or simply the way expressions are delimited, they are defined in different levels, and eventually recursing to the lowest level with parentheses wrapping expressions.","title":"Different levels of expressions"},{"location":"reference/expressions/#atomic-expressions","text":"Atomic expressions are the most basic building block for expressions. There are only three kinds of atomic expressions: Numeric literals (i.e. 123 ) Boolean literals ( true / false ) Identifiers (names of variables or functions) Numeric literals default to the i32 type. Boolean literals of course have the bool type. Identifiers' type are known where the identifier has been declared.","title":"Atomic expressions"},{"location":"reference/expressions/#primary-expressions","text":"Primary expressions are the basic structure from which expressions can be constructed recursively. There are three kinds of primary expressions: Atomic expressions (of course atomic expressions can be used to construct higher order expressions) \"Grouped\" expressions: parenthesised expressions . This allows breaking operator precedence Block expressions: a language construct which wraps zero or more statements in an expression, which allows writing imperative code in conditional expressions for example Grouped expressions have the type of the wrapped expressions. As of 2.0, block expressions have the unit type () .","title":"Primary expressions"},{"location":"reference/expressions/#operation-expressions","text":"Operation expressions are the result of applying operators on primary expressions . An application of zero operators on a primary expression also counts as a valid operation expression. For a full list of operators, see the operator table .","title":"Operation expressions"},{"location":"reference/expressions/#conditional-expressions","text":"Conditional expressions are the most basic control flow structure in FunChill. In total, 4 conditional expressions exist: if if ... else unless unless ... else The expressions if and unless with no else are formed of 2 sub-expressions. if ... else and unless ... else are formed of 3 sub-expressions. All sub-expressions part of conditional expressions can be any type of expression . The expression unless (A) ... is just syntactic sugar for if (!A) ... . The condition is considered satisfied when it evaluates to true in the case of if , and when it evaluates to false in the case of unless . All four conditional expressions expect their condition as a parenthesised expression of type bool . In the case of if / unless without an else arm, an expression of type () is expected after the condition. If and only if the condition is satisfied, then the expression will be evaluated (and may produce side effects), then the control flow will continue right after, no matter whether the condition has been satisfied. These conditionals will always evaluate to () . In the case of if ... else and unless ... else , a second expression is expected after the else block. Both expressions before and after the else must be of the same type. If the condition is satisfied, the first expression will be evaluated and the whole conditional will evaluate to its first arm. Otherwise, the second expression will be evaluted and the whole conditional will evaluate to its second arm.","title":"Conditional expressions"},{"location":"reference/expressions/#conditional-loops","text":"Conditional loops are a simple control flow structure in FunChill, some of them are someway similar to conditional expressions. In total, 4 conditional loops exist: while until do ... while do ... until The expressions while and until with no do are formed of 2 sub-expressions. do ... while and do ... until are also formed of 2 sub-expressions but they evaluate them in the reverse order. All sub-expressions part of conditional loops can be any type of expression . The expression until (A) ... is just syntactic sugar for while (!A) ... . The condition is considered satisfied when it evaluates to true in the case of while , and when it evaluates to false in the case of until . All four conditional loops expect their condition as a parenthesised expression of type bool . In the case of while / until , an expression of type () is expected after the condition. If and only if the condition is satisfied, then the expression will be evaluated (and may produce side effects), then the control flow will re-evaluate the whole loop until the condition is no longer satisfied. In the case of do ... while and do ... until , a do keyword followed by an expression of type () is expected before the condition. The expression is evaluated before the control flow evaluates the condition. As for while / until loops, if the condition is evaluated to true / false , the whole loop is re-evaluated. After a conditional loop ends, the control flow continue to evaluate the next instructions.","title":"Conditional loops"},{"location":"reference/expressions/#iterative-loops","text":"Iterative loops are a complex control flow structure in FunChill with a behavior similar to conditional loops. Only one iterative loops exists: for ... in The expression for ... in is formed of 2 statements and 1 sub-expression: a variable declaration, a range definition (defined as (a,b) ), an expression of any type . The for ... in loop first declares a locally scoped integer variable and assigns it to the first value of the range. The control flow then evaluates the sub-expression and increment the local variable of 1 . The control flow re-evaluate the loop (except the variable declaration) until the variable becomes equal to or greater than the last value of the range. After an iterative loop ends, the control flow continue as for conditional loops.","title":"Iterative loops"},{"location":"reference/expressions/#general-expressions","text":"\"General\" expressions are what is commonly referred to as \"expressions\" in the rest of this documentation. They can be either operation expressions or conditional expressions . Note that since operations expressions are made of zero or more operations, an atomic expression such as 3 will indeed qualify as a \"general\" expression. Back to reference index","title":"General expressions"},{"location":"reference/grammar/","text":"FunChill formal grammar The FunChill formal grammar is written as PEG (parsing expression grammar), a formal syntax designed to unambiguously describe various grammars. Grammar Root <- TopLevelDeclNotMain* MainFunction TopLevelDeclNotMain* EndOfFile ### Top level declarations ### # Top level declarations which are not the main function TopLevelDeclNotMain <- FunctionDeclaration FunctionDeclaration <- FunctionSignature FunctionBody MainFunction <- KeyW_main ParameterList? FunctionBody FunctionSignature <- KeyW_fun Identifier ParameterList? ReturnType? FunctionBody <- BlockExpression AnySpacing ReturnType <- Colon Type AnySpacing ParameterList <- OpenParen VariableDeclarationList CloseParen VariableDeclarationList <- VariableDeclaration? (Comma VariableDeclaration)* Comma? ### Block level ### # Blocks can actually be evaluated as expressions BlockExpression <- OpenBrace Statement* CloseBrace Statement <- ( Expression / VariableDeclarationStatement / AssignStatement / ReturnStatement ) EndOfStatement VariableDeclarationStatement <- VariableDeclaration (OperAssign Expression)? VariableDeclaration <- TypeIdentifier Identifier AssignStatement <- Identifier AssignOperator Expression ReturnStatement <- KeyW_return Expression EndOfStatement <- (Semicolon / LineBreak) AnySpacing ### Expression level ### # Expressions are listed in different categories to # express operator precedence. Expression <- IfExpr / UnlessExpr / OperationExpr IfExpr <- KeyW_if ConditionalBody UnlessExpr <- KeyW_unless ConditionalBody # if/unless condition first arm optional second arm ConditionalBody <- GroupedExpr AnySpacing Expression (AnySpacing KeyW_else Expression)? WhileExpr <- KeyW_while WhileBody UntilExpr <- KeyW_until WhileBody # while/until condition body WhileBody <- GroupedExpr AnySpacing Expression DoWhileExpr <- KeyW_do DoWhileBody # do body condition DoWhileBody <- Expression AnySpacing KeyW_while GroupedExpr ForExpr <- KeyW_for ForBody # for declaration range body ForBody <- VariableDeclaration KeyW_in ExpressionList AnySpacing GroupedExpr # OR is the least precedent operator, so an \"operation\" # (combination of any number of operators) is a LogicalOrExpr OperationExpr <- LogicalOrExpr LogicalOrExpr <- LogicalAndExpr (LogicalOrOperator LogicalAndExpr)* LogicalAndExpr <- EqualityExpr (LogicalAndOperator EqualityExpr)* EqualityExpr <- ComparisonExpr (EqualityOperator ComparisonExpr)* ComparisonExpr <- AdditionExpr (ComparisonOperator AdditionExpr)* AdditionExpr <- MultiplicationExpr (AdditionOperator MultiplicationExpr)* MultiplicationExpr <- PrefixOpExpr (MultiplicationOperator PrefixOpExpr)* PrefixOpExpr <- PrefixOperator* SuffixOpExpr SuffixOpExpr <- PrimaryExpr SuffixOperator* # Basic expression with no operator applied -- highest precedence PrimaryExpr <- AtomicExpr / GroupedExpr / BlockExpression GroupedExpr <- OpenParen Expression CloseParen # An expression which is not composed of subexpressions AtomicExpr <- NumericLiteral / BooleanLiteral / Identifier ### Identifiers ### # Alphanumeric constructs which are not keywords are identifiers TypeIdentifier <- Identifier # For now, type identifiers are the same as others Identifier <- !Keyword IdentStart IdentCont* InlineSpacing IdentStart <- [a-zA-Z_] IdentCont <- IdentStart / [0-9] ### Type literals ### Type <- PrimaryType # / UserDefinedType # For when we will have user-defined types PrimaryType <- ('bool' / IntegerType) InlineSpacing IntegerType <- ( 'i' / 'u' ) ( '8' / '16' / '32' / '64' ) InlineSpacing ### Literals ### BooleanLiteral <- KeyW_true / KeyW_false NumericLiteral <- [0-9]+ InlineSpacing ### Keywords ### # We specify EndOfWord after each keyword so that # \"funny\" does not match the 'fun' keyword for example. # # Most keywords allow linebreaks to allow placing expressions on separate # lines without opening braces. Keyword <- KeyW_fun / KeyW_if / keyW_unless / KeyW_else / KeyW_while / KeyW_until / KeyW_do / KeyW_for / KeyW_in / KeyW_return / KeyW_true / KeyW_false / KeyW_main KeyW_fun <- 'fun' EndOfWord AnySpacing KeyW_if <- 'if' EndOfWord AnySpacing KeyW_unless <- 'unless' EndOfWord AnySpacing KeyW_else <- 'else' EndOfWord AnySpacing KeyW_while <- 'while' EndOfWord AnySpacing KeyW_until <- 'until' EndOfWord AnySpacing KeyW_do <- 'do' EndOfWord AnySpacing KeyW_for <- 'for' EndOfWord AnySpacing KeyW_in <- 'in' EndOfWord AnySpacing KeyW_return <- 'return' EndOfWord InlineSpacing # 'return' can be a statement on its own KeyW_true <- 'true' EndOfWord InlineSpacing KeyW_false <- 'false' EndOfWord InlineSpacing KeyW_main <- 'main' EndOfWord AnySpacing ### Operators ### # All operators allow line breaks, hence the AnySpacing AssignOperator <- OperAssign # / OperAssignAdd # / OperAssignSub # (for when have more assign operators) LogicalOrOperator <- OperOr LogicalAndOperator <- OperAnd EqualityOperator <- OperEquals / OperDiffers ComparisonOperator <- OperGt / OperLt / OperGe / OperLe AdditionOperator <- OperAdd / OperSub MultiplicationOperator <- OperMul / OperDiv / OperMod PrefixOperator <- OperAdd / OperSub / OperNot SuffixOperator <- OperFunctionCall # / <other suffix operators>, such as [], potentially ++, --, # We define function calls as a suffix operator to allow first-class functions OperFunctionCall <- OpenParen ExpressionList CloseParen ExpressionList <- Expression? (Comma Expression)* Comma? OperAssign <- '=' ![=] AnySpacing OperAdd <- '+' ![=] AnySpacing OperSub <- '-' ![=] AnySpacing OperMul <- '*' ![=] AnySpacing OperDiv <- '/' ![=] AnySpacing OperMod <- '%' ![=] AnySpacing OperEquals <- '==' AnySpacing OperDiffers <- '!=' AnySpacing OperNot <- '!' ![=] AnySpacing OperAnd <- '&&' AnySpacing OperOr <- '||' AnySpacing OperGt <- '>' ![=] AnySpacing OperLt <- '<' ![=] AnySpacing OperGe <- '<=' AnySpacing OperLe <- '>=' AnySpacing ### Primitive separators ### # We allow AnySpacing after any kind of opening bracket # so that they can introduce multiline expressions. # Commas too consume AnySpacing so that they can continue multiline # expressions. This neatly allows multiline lists without cluttering # the Expression grammar. OpenParen <- '(' AnySpacing CloseParen <- ')' InlineSpacing # OpenBrack <- '[' AnySpacing # Square brackets are unused for now # CloseBrack <- ']' InlineSpacing # Square brackets are unused for now OpenBrace <- '{' AnySpacing CloseBrace <- '}' InlineSpacing Comma <- ',' AnySpacing Semicolon <- ';' AnySpacing Colon <- ':' AnySpacing ### Blanks: spaces and newlines ### EndOfWord <- ![a-zA-Z0-9] InlineSpacing AnySpacing <- (InlineSpacing / LineBreak)* InlineSpacing <- (InlineSpace / LineComment / BlockComment)* LineComment <- '//' (!LineBreak .)* BlockComment <- '/*' ( !'*/' .)* '*/' InlineSpace <- ' ' / '\\t' / ('\\\\' LineBreak) # End of lines can be escaped LineBreak <- !'\\\\' ('\\n' / '\\r\\n') EndOfFile <- !. Back to reference index","title":"Grammar"},{"location":"reference/grammar/#funchill-formal-grammar","text":"The FunChill formal grammar is written as PEG (parsing expression grammar), a formal syntax designed to unambiguously describe various grammars.","title":"FunChill formal grammar"},{"location":"reference/grammar/#grammar","text":"Root <- TopLevelDeclNotMain* MainFunction TopLevelDeclNotMain* EndOfFile ### Top level declarations ### # Top level declarations which are not the main function TopLevelDeclNotMain <- FunctionDeclaration FunctionDeclaration <- FunctionSignature FunctionBody MainFunction <- KeyW_main ParameterList? FunctionBody FunctionSignature <- KeyW_fun Identifier ParameterList? ReturnType? FunctionBody <- BlockExpression AnySpacing ReturnType <- Colon Type AnySpacing ParameterList <- OpenParen VariableDeclarationList CloseParen VariableDeclarationList <- VariableDeclaration? (Comma VariableDeclaration)* Comma? ### Block level ### # Blocks can actually be evaluated as expressions BlockExpression <- OpenBrace Statement* CloseBrace Statement <- ( Expression / VariableDeclarationStatement / AssignStatement / ReturnStatement ) EndOfStatement VariableDeclarationStatement <- VariableDeclaration (OperAssign Expression)? VariableDeclaration <- TypeIdentifier Identifier AssignStatement <- Identifier AssignOperator Expression ReturnStatement <- KeyW_return Expression EndOfStatement <- (Semicolon / LineBreak) AnySpacing ### Expression level ### # Expressions are listed in different categories to # express operator precedence. Expression <- IfExpr / UnlessExpr / OperationExpr IfExpr <- KeyW_if ConditionalBody UnlessExpr <- KeyW_unless ConditionalBody # if/unless condition first arm optional second arm ConditionalBody <- GroupedExpr AnySpacing Expression (AnySpacing KeyW_else Expression)? WhileExpr <- KeyW_while WhileBody UntilExpr <- KeyW_until WhileBody # while/until condition body WhileBody <- GroupedExpr AnySpacing Expression DoWhileExpr <- KeyW_do DoWhileBody # do body condition DoWhileBody <- Expression AnySpacing KeyW_while GroupedExpr ForExpr <- KeyW_for ForBody # for declaration range body ForBody <- VariableDeclaration KeyW_in ExpressionList AnySpacing GroupedExpr # OR is the least precedent operator, so an \"operation\" # (combination of any number of operators) is a LogicalOrExpr OperationExpr <- LogicalOrExpr LogicalOrExpr <- LogicalAndExpr (LogicalOrOperator LogicalAndExpr)* LogicalAndExpr <- EqualityExpr (LogicalAndOperator EqualityExpr)* EqualityExpr <- ComparisonExpr (EqualityOperator ComparisonExpr)* ComparisonExpr <- AdditionExpr (ComparisonOperator AdditionExpr)* AdditionExpr <- MultiplicationExpr (AdditionOperator MultiplicationExpr)* MultiplicationExpr <- PrefixOpExpr (MultiplicationOperator PrefixOpExpr)* PrefixOpExpr <- PrefixOperator* SuffixOpExpr SuffixOpExpr <- PrimaryExpr SuffixOperator* # Basic expression with no operator applied -- highest precedence PrimaryExpr <- AtomicExpr / GroupedExpr / BlockExpression GroupedExpr <- OpenParen Expression CloseParen # An expression which is not composed of subexpressions AtomicExpr <- NumericLiteral / BooleanLiteral / Identifier ### Identifiers ### # Alphanumeric constructs which are not keywords are identifiers TypeIdentifier <- Identifier # For now, type identifiers are the same as others Identifier <- !Keyword IdentStart IdentCont* InlineSpacing IdentStart <- [a-zA-Z_] IdentCont <- IdentStart / [0-9] ### Type literals ### Type <- PrimaryType # / UserDefinedType # For when we will have user-defined types PrimaryType <- ('bool' / IntegerType) InlineSpacing IntegerType <- ( 'i' / 'u' ) ( '8' / '16' / '32' / '64' ) InlineSpacing ### Literals ### BooleanLiteral <- KeyW_true / KeyW_false NumericLiteral <- [0-9]+ InlineSpacing ### Keywords ### # We specify EndOfWord after each keyword so that # \"funny\" does not match the 'fun' keyword for example. # # Most keywords allow linebreaks to allow placing expressions on separate # lines without opening braces. Keyword <- KeyW_fun / KeyW_if / keyW_unless / KeyW_else / KeyW_while / KeyW_until / KeyW_do / KeyW_for / KeyW_in / KeyW_return / KeyW_true / KeyW_false / KeyW_main KeyW_fun <- 'fun' EndOfWord AnySpacing KeyW_if <- 'if' EndOfWord AnySpacing KeyW_unless <- 'unless' EndOfWord AnySpacing KeyW_else <- 'else' EndOfWord AnySpacing KeyW_while <- 'while' EndOfWord AnySpacing KeyW_until <- 'until' EndOfWord AnySpacing KeyW_do <- 'do' EndOfWord AnySpacing KeyW_for <- 'for' EndOfWord AnySpacing KeyW_in <- 'in' EndOfWord AnySpacing KeyW_return <- 'return' EndOfWord InlineSpacing # 'return' can be a statement on its own KeyW_true <- 'true' EndOfWord InlineSpacing KeyW_false <- 'false' EndOfWord InlineSpacing KeyW_main <- 'main' EndOfWord AnySpacing ### Operators ### # All operators allow line breaks, hence the AnySpacing AssignOperator <- OperAssign # / OperAssignAdd # / OperAssignSub # (for when have more assign operators) LogicalOrOperator <- OperOr LogicalAndOperator <- OperAnd EqualityOperator <- OperEquals / OperDiffers ComparisonOperator <- OperGt / OperLt / OperGe / OperLe AdditionOperator <- OperAdd / OperSub MultiplicationOperator <- OperMul / OperDiv / OperMod PrefixOperator <- OperAdd / OperSub / OperNot SuffixOperator <- OperFunctionCall # / <other suffix operators>, such as [], potentially ++, --, # We define function calls as a suffix operator to allow first-class functions OperFunctionCall <- OpenParen ExpressionList CloseParen ExpressionList <- Expression? (Comma Expression)* Comma? OperAssign <- '=' ![=] AnySpacing OperAdd <- '+' ![=] AnySpacing OperSub <- '-' ![=] AnySpacing OperMul <- '*' ![=] AnySpacing OperDiv <- '/' ![=] AnySpacing OperMod <- '%' ![=] AnySpacing OperEquals <- '==' AnySpacing OperDiffers <- '!=' AnySpacing OperNot <- '!' ![=] AnySpacing OperAnd <- '&&' AnySpacing OperOr <- '||' AnySpacing OperGt <- '>' ![=] AnySpacing OperLt <- '<' ![=] AnySpacing OperGe <- '<=' AnySpacing OperLe <- '>=' AnySpacing ### Primitive separators ### # We allow AnySpacing after any kind of opening bracket # so that they can introduce multiline expressions. # Commas too consume AnySpacing so that they can continue multiline # expressions. This neatly allows multiline lists without cluttering # the Expression grammar. OpenParen <- '(' AnySpacing CloseParen <- ')' InlineSpacing # OpenBrack <- '[' AnySpacing # Square brackets are unused for now # CloseBrack <- ']' InlineSpacing # Square brackets are unused for now OpenBrace <- '{' AnySpacing CloseBrace <- '}' InlineSpacing Comma <- ',' AnySpacing Semicolon <- ';' AnySpacing Colon <- ':' AnySpacing ### Blanks: spaces and newlines ### EndOfWord <- ![a-zA-Z0-9] InlineSpacing AnySpacing <- (InlineSpacing / LineBreak)* InlineSpacing <- (InlineSpace / LineComment / BlockComment)* LineComment <- '//' (!LineBreak .)* BlockComment <- '/*' ( !'*/' .)* '*/' InlineSpace <- ' ' / '\\t' / ('\\\\' LineBreak) # End of lines can be escaped LineBreak <- !'\\\\' ('\\n' / '\\r\\n') EndOfFile <- !. Back to reference index","title":"Grammar"},{"location":"reference/keywords/","text":"FunChill keywords Here is a table of all keywords found in the FunChill language Keyword Description fun Introduce a function declaration main Introduce a main function return Introduce a return statement in a function if Introduce a conditional expression unless Introduce a reverse conditional expression else Introduce a fallback in conditional expressions while Introduce a conditional loop until Introduce a reverse conditional loop do Introduce the body of a conditional loop for Introduce an iterative loop in Used to iterate over a collection in iterative loops true Boolean true constant false Boolean false constant Back to reference index","title":"Keywords"},{"location":"reference/keywords/#funchill-keywords","text":"Here is a table of all keywords found in the FunChill language Keyword Description fun Introduce a function declaration main Introduce a main function return Introduce a return statement in a function if Introduce a conditional expression unless Introduce a reverse conditional expression else Introduce a fallback in conditional expressions while Introduce a conditional loop until Introduce a reverse conditional loop do Introduce the body of a conditional loop for Introduce an iterative loop in Used to iterate over a collection in iterative loops true Boolean true constant false Boolean false constant Back to reference index","title":"FunChill keywords"},{"location":"reference/operator_table/","text":"FunChill operator precedence table Here is a table of all the available operators in FunChill, along with their associativity and precedence. Note that all suffix operators have the same precedence, and same goes for all prefix operators. The most precedent are suffix operators, then prefix (such that !myfunc() first applies function call and then negates the results), and then infix operators have different levels of precedence. Precedence Operator Type Description Associativity 1 (expr...) Suffix Function call Left-to-right 2 - Prefix Arithmetic opposite Right-to-left 2 + Prefix Arithmetic plus sign Right-to-left 2 ! Prefix Logical not operator Right-to-left 3 * Infix Multiplication Left-to-right 3 / Infix Division Left-to-right 3 % Infix Modulus Left-to-right 4 + Infix Addition Left-to-right 4 - Infix Subtraction Left-to-right 5 > Infix Greater than Left-to-right 5 < Infix Lesser than Left-to-right 5 >= Infix Greater than or equal Left-to-right 5 <= Infix Lesser than or equal Left-to-right 6 == Infix Equals Left-to-right 6 != Infix Not equals Left-to-right 6 && Infix Logical AND Left-to-right 6 || Infix Logical OR Left-to-right Back to reference index","title":"Operators"},{"location":"reference/operator_table/#funchill-operator-precedence-table","text":"Here is a table of all the available operators in FunChill, along with their associativity and precedence. Note that all suffix operators have the same precedence, and same goes for all prefix operators. The most precedent are suffix operators, then prefix (such that !myfunc() first applies function call and then negates the results), and then infix operators have different levels of precedence. Precedence Operator Type Description Associativity 1 (expr...) Suffix Function call Left-to-right 2 - Prefix Arithmetic opposite Right-to-left 2 + Prefix Arithmetic plus sign Right-to-left 2 ! Prefix Logical not operator Right-to-left 3 * Infix Multiplication Left-to-right 3 / Infix Division Left-to-right 3 % Infix Modulus Left-to-right 4 + Infix Addition Left-to-right 4 - Infix Subtraction Left-to-right 5 > Infix Greater than Left-to-right 5 < Infix Lesser than Left-to-right 5 >= Infix Greater than or equal Left-to-right 5 <= Infix Lesser than or equal Left-to-right 6 == Infix Equals Left-to-right 6 != Infix Not equals Left-to-right 6 && Infix Logical AND Left-to-right 6 || Infix Logical OR Left-to-right Back to reference index","title":"FunChill operator precedence table"},{"location":"reference/statements/","text":"FunChill statements In FunChill, statements are a language construct which expresses imperative code, contrary to expressions , which are only about combining values together. List of statements As of FunChill 2.0, only 4 four statements can be found in the language: return statements, which stop execution of the current function and optionally specify a return value Variable declaration statements: introduce a new variable into scope Assignment statements: change the value of a variable Simple expressions Where statements can be found Statements are found between { curly braces } , separated by end of statements (semicolons or linebreaks). The most common occurrence is of obvious: functions! A function body is nothing more than a block expression , thus is made of statements, like variable declarations, variable assignments, and return statements. The reason why expressions are also statements is to allow an imperative style in functions, for example calling other functions without retrieving their return value: fun do_stuff { do_thing1() do_thing2() do_thing3() } And of course, since block expressions are first class expressions, this means it is also possible to write statements only executed conditionally, by using conditional expressions : fun do_smart_stuff(i32 x) { if (x > 7) { i32 a = do_thing1() + x % 2 use_thing1(a) } use_thing2(x) } End of statements In FunChill, statements written in block expressions must be terminated by an end of statement. There are two kinds of end of statements: Semicolon ; Linebreak \\n or \\r\\n Strictly speaking, end of statements are part of statements themselves; as such, when we say that block expressions contain zero ore more statements, we imply that an end of statement must be present for each statement, including the last one. Linebreaks and semicolons can be used interchangeably as end of statements, even in the same block expression: fun f { i32 a = 15 // linebreak ends the statement a = 2; // semicolon ends the statement a = 3; a = 4; a = 5 // Several statements can be written in // in one line with semicolons } The fact that linebreaks are valid end of statements aims at making semicolons optional, so feel free to use this more idiomatic style when writing FunChill instead of cramming all your end of lines with semicolons. Making linebreaks valid end of statements comes at a cost, though: it makes splitting expressions on several lines harder, because the linebreak could be interpreted as an end of statement. To help mitigate that, FunChill gives special power to certain characters: discard any number of following linebreaks to allow multiline expressions. Those characters are: , Comma ( Opening parenthesis { Opening brace And all infix and prefix operators Linebreaks are also discarded in many places in conditional expressions, as described in the whitespace reference . In fact, you can more generally find good information and insight about how linebreaks can work as end of statement that reference. Back to reference index","title":"Statements"},{"location":"reference/statements/#funchill-statements","text":"In FunChill, statements are a language construct which expresses imperative code, contrary to expressions , which are only about combining values together.","title":"FunChill statements"},{"location":"reference/statements/#list-of-statements","text":"As of FunChill 2.0, only 4 four statements can be found in the language: return statements, which stop execution of the current function and optionally specify a return value Variable declaration statements: introduce a new variable into scope Assignment statements: change the value of a variable Simple expressions","title":"List of statements"},{"location":"reference/statements/#where-statements-can-be-found","text":"Statements are found between { curly braces } , separated by end of statements (semicolons or linebreaks). The most common occurrence is of obvious: functions! A function body is nothing more than a block expression , thus is made of statements, like variable declarations, variable assignments, and return statements. The reason why expressions are also statements is to allow an imperative style in functions, for example calling other functions without retrieving their return value: fun do_stuff { do_thing1() do_thing2() do_thing3() } And of course, since block expressions are first class expressions, this means it is also possible to write statements only executed conditionally, by using conditional expressions : fun do_smart_stuff(i32 x) { if (x > 7) { i32 a = do_thing1() + x % 2 use_thing1(a) } use_thing2(x) }","title":"Where statements can be found"},{"location":"reference/statements/#end-of-statements","text":"In FunChill, statements written in block expressions must be terminated by an end of statement. There are two kinds of end of statements: Semicolon ; Linebreak \\n or \\r\\n Strictly speaking, end of statements are part of statements themselves; as such, when we say that block expressions contain zero ore more statements, we imply that an end of statement must be present for each statement, including the last one. Linebreaks and semicolons can be used interchangeably as end of statements, even in the same block expression: fun f { i32 a = 15 // linebreak ends the statement a = 2; // semicolon ends the statement a = 3; a = 4; a = 5 // Several statements can be written in // in one line with semicolons } The fact that linebreaks are valid end of statements aims at making semicolons optional, so feel free to use this more idiomatic style when writing FunChill instead of cramming all your end of lines with semicolons. Making linebreaks valid end of statements comes at a cost, though: it makes splitting expressions on several lines harder, because the linebreak could be interpreted as an end of statement. To help mitigate that, FunChill gives special power to certain characters: discard any number of following linebreaks to allow multiline expressions. Those characters are: , Comma ( Opening parenthesis { Opening brace And all infix and prefix operators Linebreaks are also discarded in many places in conditional expressions, as described in the whitespace reference . In fact, you can more generally find good information and insight about how linebreaks can work as end of statement that reference. Back to reference index","title":"End of statements"},{"location":"reference/types/","text":"FunChill types As of FunChill 2.0, the type system is kept very simple, featuring many integer types and a boolean type. Type table Here is the full table of primary FunChill types: Type identifier Description i8 8 bits signed integer i16 16 bits signed integer i32 32 bits signed integer i64 64 bits signed integer u8 8 bits unsigned integer u16 16 bits unsigned integer u32 32 bits unsigned integer u64 64 bits unsigned integer bool Boolean value ( true / false ) () Unit type (empty tuple) (t1, t2, t3, ...) Tuple type (soon to come) Details Integers Integer types are described as short identifiers starting by either u or i , as in u nsigned integer or i nteger; the same as in Rust and Zig. Integer types can be manipulated by using arithmetic operators + , - , * , / and % . Booleans The boolean type is special because it only has two possible values, which both are keywords , contrary to numbers which are literals. They are key in conditional expressions, being the only type that can express conditions. Boolean types can be manipulated by logical operator && and || . Unit type The unit type is what might be called the \"void\" type in other languages: a type that contains no information, and has a single variant. You will likely never to write this type by hand, since the only place where it can be used is in function return types, and it can be implicitly deduced if you simply do not specify the return type . Note that you can't declare variables of type () . Not that that it would be useful, anyways. Tuple type The tuple type is meant to be a grouping of several values into a single object, which can be a first step towards defining your own data types. It is especially useful because it would allow functions to return several values at once. However, tuples are not yet implemented in the language as of 2.0. Back to reference index","title":"Types"},{"location":"reference/types/#funchill-types","text":"As of FunChill 2.0, the type system is kept very simple, featuring many integer types and a boolean type.","title":"FunChill types"},{"location":"reference/types/#type-table","text":"Here is the full table of primary FunChill types: Type identifier Description i8 8 bits signed integer i16 16 bits signed integer i32 32 bits signed integer i64 64 bits signed integer u8 8 bits unsigned integer u16 16 bits unsigned integer u32 32 bits unsigned integer u64 64 bits unsigned integer bool Boolean value ( true / false ) () Unit type (empty tuple) (t1, t2, t3, ...) Tuple type (soon to come)","title":"Type table"},{"location":"reference/types/#details","text":"","title":"Details"},{"location":"reference/types/#integers","text":"Integer types are described as short identifiers starting by either u or i , as in u nsigned integer or i nteger; the same as in Rust and Zig. Integer types can be manipulated by using arithmetic operators + , - , * , / and % .","title":"Integers"},{"location":"reference/types/#booleans","text":"The boolean type is special because it only has two possible values, which both are keywords , contrary to numbers which are literals. They are key in conditional expressions, being the only type that can express conditions. Boolean types can be manipulated by logical operator && and || .","title":"Booleans"},{"location":"reference/types/#unit-type","text":"The unit type is what might be called the \"void\" type in other languages: a type that contains no information, and has a single variant. You will likely never to write this type by hand, since the only place where it can be used is in function return types, and it can be implicitly deduced if you simply do not specify the return type . Note that you can't declare variables of type () . Not that that it would be useful, anyways.","title":"Unit type"},{"location":"reference/types/#tuple-type","text":"The tuple type is meant to be a grouping of several values into a single object, which can be a first step towards defining your own data types. It is especially useful because it would allow functions to return several values at once. However, tuples are not yet implemented in the language as of 2.0. Back to reference index","title":"Tuple type"},{"location":"reference/whitespace/","text":"Whitespace in FunChill In FunChill, whitespace is mostly ignored. This means that you are free to indent your code however you like, or add any amount of whitespace in between every word. Characters counted as \"whitespace\" As of FunChill 2.0, the only characters recognised as pure whitespace are: ASCII Space (0x20) ASCII Tab \\t (0x09) Importantly, linebreaks are not considered simple whitespace because they have an important role in functions: they can be used interchangeably with semicolons to end statements. What happens to whitespace in code Whitespace is handled by the FunChill lexer, which explicitly ignores them and produces no token when lexing whitespace. Whitespace still serves as a delimiter between identifiers, so it is not always optional. A simple example where whitespace is mandatory: // This works fun myfunc {} // This doesn't work funmyfunc {} What happens to linebreaks In FunChill, two linebreak sequences are recognised: ASCII LineFeed \\n (0x0a) ASCII CarriageReturn LineFeed \\r\\n (0X0D0A) These linebreak sequences are exceptionally ignored by the lexer when preceded by a backslash \\ (0x5C), in which case they behave as any whitespace. So, in the following example, a backslash allows writing the addition on a separate line: fun f { i32 a = 1 \\ + 2 } So, finally, what happens to linebreaks which are not escaped? In short, when outside of a function: they are simply ignored; when inside a function body: they are an alternative to semicolons as \"end of statements\". ... But they still sometimes ignored for readability. For a technical explanation of how linebreaks can be ignored within a function body, keep reading, or for a practical explanation, go to the statement reference . How linebreaks are conditionally ignored To understand the following explanation, you will need a basic understanding of how the FunChill compiler works. There are two parts of the compiler which are relevant to understand how linebreaks are ignored: The Lexer, which converts source files into a stream of tokens (identifiers, literals, operators, brackets, ...) The Parser, which converts a stream of tokens into an a bstract s yntax t ree (usually referred to as AST): a recursive data structure which expresses the syntax of the language The FunChill lexer usually converts linebreak sequences ( \\n or \\r\\n ) to Linebreak tokens, which will be included in the token stream resulting from lexing a file. Escaped linebreaks are ignored at the lexer level: when a linebreak sequence is preceded by the backslash character, it will be explicitly ignored, thus producing no token in the resulting token stream. On the other hand, linebreaks which are not escaped make it to the parser, which implements some smart rules to allow linebreaks to be an alternative to semicolons while also allowing the user to split expressions into several lines. To start with, line breaks are ignored at the top level (outside of function bodies). Within a function body, line breaks are explicitly not ignored: they are preserved preciously when parsing expressions or operator chains so that they can be consumed as an \"end of statement\" at the end. This means the following: fun f { i32 a = 8 + 2 } will be parsed the same as fun f { i32 a = 8; +2; } But thankfully, the following parses properly fun f { i32 a = 8 + 2 } How so?, well, some specific tokens discard all linebreaks directly following them. It's actually quite a big number of tokens; here is the full list: ; : , { ( All prefix and infix operators Linebreaks are also discarded between the different parts of a conditional expression: Between the if / unless and the parenthesised condition Between the condition and the first arm expression Between the first arm expression and the else (only if there is an else ) Between the else and the second arm expression such that the following are correctly parsed as single conditional expressions: fun f { // Same as if (a) b else c if (a) b else c // Same as above if (a) b else c // Same as if (a) b if (a) b } Back to reference index","title":"Whitespace"},{"location":"reference/whitespace/#whitespace-in-funchill","text":"In FunChill, whitespace is mostly ignored. This means that you are free to indent your code however you like, or add any amount of whitespace in between every word.","title":"Whitespace in FunChill"},{"location":"reference/whitespace/#characters-counted-as-whitespace","text":"As of FunChill 2.0, the only characters recognised as pure whitespace are: ASCII Space (0x20) ASCII Tab \\t (0x09) Importantly, linebreaks are not considered simple whitespace because they have an important role in functions: they can be used interchangeably with semicolons to end statements.","title":"Characters counted as \"whitespace\""},{"location":"reference/whitespace/#what-happens-to-whitespace-in-code","text":"Whitespace is handled by the FunChill lexer, which explicitly ignores them and produces no token when lexing whitespace. Whitespace still serves as a delimiter between identifiers, so it is not always optional. A simple example where whitespace is mandatory: // This works fun myfunc {} // This doesn't work funmyfunc {}","title":"What happens to whitespace in code"},{"location":"reference/whitespace/#what-happens-to-linebreaks","text":"In FunChill, two linebreak sequences are recognised: ASCII LineFeed \\n (0x0a) ASCII CarriageReturn LineFeed \\r\\n (0X0D0A) These linebreak sequences are exceptionally ignored by the lexer when preceded by a backslash \\ (0x5C), in which case they behave as any whitespace. So, in the following example, a backslash allows writing the addition on a separate line: fun f { i32 a = 1 \\ + 2 } So, finally, what happens to linebreaks which are not escaped? In short, when outside of a function: they are simply ignored; when inside a function body: they are an alternative to semicolons as \"end of statements\". ... But they still sometimes ignored for readability. For a technical explanation of how linebreaks can be ignored within a function body, keep reading, or for a practical explanation, go to the statement reference .","title":"What happens to linebreaks"},{"location":"reference/whitespace/#how-linebreaks-are-conditionally-ignored","text":"To understand the following explanation, you will need a basic understanding of how the FunChill compiler works. There are two parts of the compiler which are relevant to understand how linebreaks are ignored: The Lexer, which converts source files into a stream of tokens (identifiers, literals, operators, brackets, ...) The Parser, which converts a stream of tokens into an a bstract s yntax t ree (usually referred to as AST): a recursive data structure which expresses the syntax of the language The FunChill lexer usually converts linebreak sequences ( \\n or \\r\\n ) to Linebreak tokens, which will be included in the token stream resulting from lexing a file. Escaped linebreaks are ignored at the lexer level: when a linebreak sequence is preceded by the backslash character, it will be explicitly ignored, thus producing no token in the resulting token stream. On the other hand, linebreaks which are not escaped make it to the parser, which implements some smart rules to allow linebreaks to be an alternative to semicolons while also allowing the user to split expressions into several lines. To start with, line breaks are ignored at the top level (outside of function bodies). Within a function body, line breaks are explicitly not ignored: they are preserved preciously when parsing expressions or operator chains so that they can be consumed as an \"end of statement\" at the end. This means the following: fun f { i32 a = 8 + 2 } will be parsed the same as fun f { i32 a = 8; +2; } But thankfully, the following parses properly fun f { i32 a = 8 + 2 } How so?, well, some specific tokens discard all linebreaks directly following them. It's actually quite a big number of tokens; here is the full list: ; : , { ( All prefix and infix operators Linebreaks are also discarded between the different parts of a conditional expression: Between the if / unless and the parenthesised condition Between the condition and the first arm expression Between the first arm expression and the else (only if there is an else ) Between the else and the second arm expression such that the following are correctly parsed as single conditional expressions: fun f { // Same as if (a) b else c if (a) b else c // Same as above if (a) b else c // Same as if (a) b if (a) b } Back to reference index","title":"How linebreaks are conditionally ignored"}]}